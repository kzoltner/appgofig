package appgofig

import (
	"fmt"
	"log"
	"os"
	"reflect"
	"strings"
	"time"
)

// NewAppGofig Creates a new AppGofig. You need to Initialize it using .Init() on the return value
func NewAppGofig[T StructOnly](configDescriptions map[string]string) *AppGofig[T] {
	gofig := AppGofig[T]{
		Descriptions: configDescriptions,
		Cfg:          T{},
	}

	return &gofig
}

// CreateMarkdownFile creates a simple markdown table with information about the provided config inputs
func CreateMarkdownFile[T StructOnly](markdownFilePath string, configDescriptions map[string]string) error {
	var sb strings.Builder

	sb.WriteString("| YAML Key | ENV Key | Type | Required | Default | Description |\n")
	sb.WriteString("|---|---|---|---|---|---|\n")

	t := reflect.TypeFor[T]()
	for k := 0; k < t.NumField(); k++ {
		field := t.Field(k)
		yamlKey := field.Name
		envKey := field.Tag.Get("env")

		defaultValue := field.Tag.Get("default")
		description := configDescriptions[yamlKey]

		required := "no"
		if field.Tag.Get("req") == "true" {
			required = "yes"
		}

		// Write Markdown row
		sb.WriteString("| " + yamlKey + " | " + envKey + " | " + field.Type.Kind().String() + " | " + required + " | " + defaultValue + " | " + description + " |\n")
	}

	markdownFile, err := os.Create(markdownFilePath)
	if err != nil {
		return fmt.Errorf("unable to create config markdown file (%q): %w", markdownFilePath, err)
	}

	if _, err := markdownFile.WriteString(sb.String()); err != nil {
		return fmt.Errorf("unable to write to config markdown file (%q): %w", markdownFilePath, err)
	}

	return nil
}

// CreateYamlExampleFile creates an example yaml file with comments providing the description and applied defaults
func CreateYamlExampleFile[T StructOnly](yamlExampleFilePath string, configDescriptions map[string]string) error {
	var sb strings.Builder

	currentTimeString := time.Now().Format(time.RFC3339)

	sb.WriteString("# Autogenerated config.yml.example file. Please provide your own values here.\n")
	fmt.Fprintf(&sb, "# Generated on %s \n\n", currentTimeString)

	t := reflect.TypeFor[T]()
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		yamlKey := field.Name

		defaultValue := field.Tag.Get("default")
		description := configDescriptions[field.Name]

		required := " - optional"
		if field.Tag.Get("required") == "true" {
			required = " - required"
		}

		// Write Row
		fmt.Fprintf(&sb, "# %s [%s%s] - %s \n", yamlKey, field.Type.Kind().String(), required, description)
		fmt.Fprintf(&sb, "%s:%s\n\n", yamlKey, defaultValue)
	}

	configExampleYaml, err := os.Create(yamlExampleFilePath)
	if err != nil {
		return fmt.Errorf("unable to create example config yaml file (%q): %w", yamlExampleFilePath, err)
	}

	if _, err := configExampleYaml.WriteString(sb.String()); err != nil {
		return fmt.Errorf("unable to write example config yaml to file (%q): %w", yamlExampleFilePath, err)
	}

	return nil
}

// Init creates the AppGofig, reads env and yaml (in that order) and applies their values to appgofig.Cfg
func (gofig *AppGofig[T]) Init() error {
	// check config struct for errors
	// TODO: Actually check for tags and stuff

	// map config struct
	configEntries := createConfigMap[T]()

	// check for env
	applyEnvConfigIfPresent(configEntries)

	// check for yaml
	if err := applyYamlConfigIfPresent(configEntries); err != nil {
		return err
	}

	// apply config entries to .Cfg
	if err := gofig.applyConfigEntries(configEntries); err != nil {
		return err
	}

	return nil
}

// InitWithValues is similar to Init(), but does not read env or yaml - instead only using whats in values. Useful for testing.
func (gofig *AppGofig[T]) InitWithTestValues(values map[string]string) error {
	configEntries := createConfigMap[T]()

	for key := range configEntries {
		if newVal, ok := values[key]; ok {
			configEntries[key].RawInput = newVal
		}
	}

	if err := gofig.applyConfigEntries(configEntries); err != nil {
		return err
	}

	return nil
}

// GetConfig returns the actual Config Struct
func (gofig *AppGofig[T]) GetConfig() T {
	return gofig.Cfg
}

// LogToConsole logs the actual configuration to the console
func (gofig *AppGofig[T]) LogToConsole() {
	log.Println("### AppGofig Configuration Start ###")

	t := reflect.TypeFor[T]()
	v := reflect.ValueOf(gofig.Cfg)

	for k := 0; k < t.NumField(); k++ {
		field := t.Field(k)
		val := v.Field(k)

		key := field.Name
		stringVal := valueToString(val)

		if ShouldBeMasked(key) {
			stringVal = fmt.Sprintf("[Masked - Length: %d]", len(stringVal))
		}

		log.Printf(" | %s : %s\n", key, stringVal)
	}

	log.Println("### AppGofig Configuration End ###")
}

// applyConfigEntries takes the values in configInput and actually writes them to cfg
func (gofig *AppGofig[T]) applyConfigEntries(configEntries map[string]*ConfigEntry) error {
	// check if all required envs are non-empty
	for key, entry := range configEntries {
		if entry.IsRequired {
			if len(configEntries[key].RawInput) == 0 {
				return fmt.Errorf("required config key %q is empty", key)
			}
		}
	}

	// convert all non-empty or required keys to their type and set them
	for key, entry := range configEntries {
		if entry.IsRequired || len(configEntries[key].RawInput) != 0 {
			// all required or non-empty keys need to match their type
			val, err := stringToValue(entry.RawInput, entry.FieldType)
			if err != nil {
				return fmt.Errorf("invalid config value for key %q using input %q caused by: %w", key, entry.RawInput, err)
			}

			entry.Value = val
		}
	}
	// set all values to config struct
	confTypes := reflect.TypeFor[T]()
	confValues := reflect.ValueOf(gofig.Cfg).Elem()

	for k := 0; k < confTypes.NumField(); k++ {
		field := confTypes.Field(k)
		val := confValues.Field(k)

		switch field.Type.Kind() {
		case reflect.String:
			val.SetString(configEntries[field.Name].Value.(string))
		case reflect.Bool:
			val.SetBool(configEntries[field.Name].Value.(bool))
		case reflect.Int64:
			val.SetInt(configEntries[field.Name].Value.(int64))
		case reflect.Float64:
			val.SetFloat(configEntries[field.Name].Value.(float64))
		}
	}

	return nil
}
